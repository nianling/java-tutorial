(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{691:function(t,a,s){"use strict";s.r(a);var n=s(21),e=Object(n.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"pattern方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pattern方法","aria-hidden":"true"}},[t._v("#")]),t._v(" Pattern方法")]),t._v(" "),s("p",[t._v("到目前为止，我们只使用测试工具来创建 Pattern 最基本的对象。本节探讨了先进的技术，例如使用标志创建模式并使用嵌入式标志表达式。\n它还探讨了一些尚未讨论的其他有用的方法。")]),t._v(" "),s("h2",{attrs:{id:"用标志创建-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用标志创建-pattern","aria-hidden":"true"}},[t._v("#")]),t._v(" 用标志创建 Pattern")]),t._v(" "),s("p",[t._v("在 Pattern 类定义的替代 compile，它接受一组影响匹配的方式的标志方法。flags 参数是一个位掩码，可以包含以下任何公共静态字段：")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("Pattern.CANON_EQ")])]),t._v(" "),s("p",[t._v('启用规范等价。指定此标志后，当且仅当其完整规范分解匹配时，两个字符才可视为匹配。\n例如，当指定此标志时，表达式 "a\\u030A" 将与字符串 "\\u00E5" 匹配。默认情况下，匹配不考虑采用规范等价。指定此标志可能会造成性能损失。')])]),t._v(" "),s("li",[s("p",[t._v("Pattern.CASE_INSENSITIVE")]),t._v(" "),s("p",[t._v("启用不区分大小写的匹配。默认情况下，不区分大小写的匹配假定仅匹配 US-ASCII 字符集中的字符。\n可以通过指定 UNICODE_CASE 标志连同此标志来启用 Unicode 感知的、不区分大小写的匹配。\n通过嵌入式标志表达式  (?i) 也可以启用不区分大小写的匹配。 指定此标志可能会造成轻微的性能损失。")])]),t._v(" "),s("li",[s("p",[t._v("Pattern.COMMENTS")]),t._v(" "),s("p",[t._v("模式中允许空白和注释。 此模式将忽略空白和在结束行之前以 # 开头的嵌入式注释。 通过嵌入式标志表达式  (?x) 也可以启用注释模式。")])]),t._v(" "),s("li",[s("p",[t._v("Pattern.DOTALL")]),t._v(" "),s("p",[t._v("启用点阵模式。在 dotall 模式下，表达式 "),s("code",[t._v(".")]),t._v(" 匹配任何字符，包括行终止符。默认情况下，\n此表达式与行终止符不匹配。Dotall 模式也可以通过嵌入式标志表达式启用(?s)。（s 是“单行”模式的助记符，这在 Perl 中也被使用）。")])]),t._v(" "),s("li",[s("p",[t._v("Pattern.LITERAL")]),t._v(" "),s("p",[t._v("启用模式的文字解析。当指定此标志时，指定模式的输入字符串将被视为文字字符序列。输入序列中的元字符或转义序列将没有特殊意义。当与此标志一起使用时，标志 CASE_INSENSITIVE 和 UNICODE_CASE 保留对匹配的影响。其他旗帜变得多余。没有嵌入的标志字符用于启用文字解析。")])]),t._v(" "),s("li",[s("p",[t._v("Pattern.MULTILINE")]),t._v(" "),s("p",[t._v("启用多行模式。在多行模式中，表达式^和$匹配恰好在之前或之前分别是行终止符或输入序列的结尾。\n默认情况下，这些表达式仅在整个输入序列的开头和结尾匹配。也可以通过嵌入式标志表达式启用多模式模式(?m)。")])]),t._v(" "),s("li",[s("p",[t._v("Pattern.UNICODE_CASE")]),t._v(" "),s("p",[t._v("启用 Unicode 感知的大小写折叠。当指定此标志时，不区分大小写的匹配（由 CASE_INSENSITIVE 标志启用）以与 Unicode 标准一致的方式完成。\n默认情况下，不区分大小写的匹配假定仅匹配 US-ASCII 字符集中的字符。Unicode 感知案例折叠也可以通过嵌入式标志表达式启用(?u)。\n指定此标志可能会造成性能损失。")])]),t._v(" "),s("li",[s("p",[t._v("Pattern.UNIX_LINES 启用 UNIX 线路模式。在这种模式下，只有'\\n' 行结束在行为的认可.，^ 和 $。\nUNIX 线路模式也可以通过嵌入式标志表达式启用(?d)。")])])]),t._v(" "),s("p",[t._v("在以下步骤中，我们将修改测试工具， RegexTestHarness.java 创建一个不区分大小写匹配的模式。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("Pattern pattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("CASE_INSENSITIVE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Test code "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("regexTest")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dog"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"DoGDOg"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Output "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  dog\n我发现文本中的 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"DoG"')]),t._v(" 在开始索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" 和 结束索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("\n我发现文本中的 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"DOg"')]),t._v(" 在开始索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" 和 结束索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6.")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("正如你所看到的，字符串文字“狗”匹配两种情况，不管情况如何。要编译具有多个标志的模式，请使用按位 OR 运算符“ |” 分隔要包含的标志。\n为了清楚起见，以下代码示例对正则表达式进行硬编码，而不是从以下代码中读取 Console：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("pattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"[az]$"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MULTILINE "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("UNIX_LINES"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n也可以指定一个变量\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("CASE_INSENSITIVE "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("UNICODE_CASE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nPattern pattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aa"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h2",{attrs:{id:"嵌入式标志表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#嵌入式标志表达式","aria-hidden":"true"}},[t._v("#")]),t._v(" 嵌入式标志表达式")]),t._v(" "),s("p",[t._v("也可以使用嵌入式标志表达式启用各种标志。嵌入式标志表达式是双参数版本的替代 compile，并在正则表达式本身中指定。\n以下示例使用原始测试工具， RegexTestHarness.java 使用嵌入式标志表达式 (?i) 来启用不区分大小写的匹配。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Test code "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("regexTest")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"(?i)foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"FOOfooFoOfoO"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Output "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("foo\n我发现文本中的 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"FOO"')]),t._v(" 在开始索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" 和 结束索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("\n我发现文本中的 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),t._v(" 在开始索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" 和 结束索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6.")]),t._v("\n我发现文本中的 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"FoO"')]),t._v(" 在开始索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v(" 和 结束索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9.")]),t._v("\n我发现文本中的 "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foO"')]),t._v(" 在开始索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v(" 和 结束索引 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12.")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("无论情况如何，所有匹配再次成功。")]),t._v(" "),s("p",[t._v("对应于Pattern可公开访问的字段的嵌入式标志表达式如下表所示：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("变量")]),t._v(" "),s("th",[t._v("等效嵌入式标志表达式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Pattern.CANON_EQ")]),t._v(" "),s("td",[t._v("没有")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.CASE_INSENSITIVE")]),t._v(" "),s("td",[t._v("(?i)")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.COMMENTS")]),t._v(" "),s("td",[t._v("(?x)")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.MULTILINE")]),t._v(" "),s("td",[t._v("(?m)")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.DOTALL")]),t._v(" "),s("td",[t._v("(?s)")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.LITERAL")]),t._v(" "),s("td",[t._v("没有")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.UNICODE_CASE")]),t._v(" "),s("td",[t._v("(?u)")])]),t._v(" "),s("tr",[s("td",[t._v("Pattern.UNIX_LINES")]),t._v(" "),s("td",[t._v("(?d)")])])])]),t._v(" "),s("h2",{attrs:{id:"matches-string-charsequence"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#matches-string-charsequence","aria-hidden":"true"}},[t._v("#")]),t._v(" matches(String,CharSequence)")]),t._v(" "),s("p",[t._v("Pattern 类定义了一个方便的 "),s("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#matches-java.lang.String-java.lang.CharSequence-",target:"_blank",rel:"noopener noreferrer"}},[t._v("matches"),s("OutboundLink")],1),t._v(" 方法，可以让你快速地检查模式是否出现在给定的输入字符串。")]),t._v(" "),s("p",[t._v("与所有公共静态方法一样，您应该 matches 通过其类名称来调用"),s("code",[t._v('Pattern.matches("\\\\d","1");')]),t._v("。\n在此示例中，该方法返回 true，因为数字“1”与正则表达式匹配 "),s("code",[t._v("\\d")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"split-charsequence-input"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#split-charsequence-input","aria-hidden":"true"}},[t._v("#")]),t._v(" split(CharSequence input)")]),t._v(" "),s("p",[t._v("split 方法是一种很好的工具，用于收集位于匹配模式两侧的文本。如下示例，该 split 方法可以从字符串“one2️⃣three4️⃣five”\n中提取单词 “one two three four five”")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  String REGEX "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('":"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  String INPUT "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"one:two:three:four:five"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  Pattern pattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("REGEX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" split "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("split")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("INPUT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  System"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Arrays"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("split"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Output "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("one"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" two"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" three"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" four"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" five"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[t._v("为了简单起见，我们匹配了字符串文字，冒号（:）而不是复杂的正则表达式。由于我们仍在使用 Pattern 和 Matcher 对象，\n您可以使用 split 来获取任何正则表达式两边的文本。这是同样的例子，按数字拆分")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  String REGEX "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\\\d"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  String INPUT "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"one9two4three7four1five"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  Pattern pattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("REGEX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" split "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pattern"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("split")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("INPUT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  System"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Arrays"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("split"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Output "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("one"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" two"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" three"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" four"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" five"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("h2",{attrs:{id:"其他实用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他实用方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 其他实用方法")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("public static String quote(String s)")])]),t._v(" "),s("p",[t._v("返回指定 String 的字面值模式 String，此方法产生一个 String，可以将其用于创建与字符串 s 匹配的 Pattern，\n就好像它是字面值模式一样。输入序列中的元字符和转义序列不具有任何特殊意义。")]),t._v(" "),s("p",[t._v('尝试了下，没有搞懂是啥，返回的全是 "'),s("code",[t._v("\\Qxxx\\E")]),t._v('" 的串')])]),t._v(" "),s("li",[s("p",[s("code",[t._v("public String toString()")])]),t._v(" "),s("p",[t._v("返回 String 此模式的表示。这是编译此模式的正则表达式。")])])]),t._v(" "),s("h2",{attrs:{id:"与-java-lang-string-等效的几个方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与-java-lang-string-等效的几个方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 与 java.lang.String 等效的几个方法")]),t._v(" "),s("p",[s("code",[t._v("java.lang.String")]),t._v(" 通过几种模仿行为的方法也存在正则表达式支持 "),s("code",[t._v("java.util.regex.Pattern")]),t._v(" 中。为方便起见，他们的 API 的关键摘录如下。")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("public boolean matches(String regex)")]),t._v("：")]),t._v(" "),s("p",[t._v("告诉这个字符串是否匹配给定的正则表达式。这种形式的这种方法的调用产生与表达式完全相同的结果。"),s("code",[t._v("str.matches(regex) 和 Pattern.matches(regex, str)")])])]),t._v(" "),s("li",[s("p",[s("code",[t._v("public String[] split(String regex, int limit)")]),t._v("：")]),t._v(" "),s("p",[t._v("将此字符串拆分为给定正则表达式的匹配项。这种形式的方法的调用产生与表达式相同的结果 "),s("code",[t._v("str.split(regex, n) 和 Pattern.compile(regex).split(str, n)")])])]),t._v(" "),s("li",[s("p",[s("code",[t._v("public String[] split(String regex)")]),t._v("：")]),t._v(" "),s("p",[t._v("将此字符串拆分为给定则表达式的匹配项。此方法的工作方式与使用给定表达式和极限参数为零的双参数拆分方法相同。尾随的空字符串不包含在结果数组中。")])])]),t._v(" "),s("p",[t._v("还有一个替换方法，替换CharSequence另一个：")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("public String replace(CharSequence target,CharSequence replacement)")]),t._v(" ：")]),t._v(" "),s("p",[t._v("将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。替换从字符串开始到结束，例如，在字符串“aaa”中用“b”替换“aa”将导致“ba”而不是“ab”。")])])])])},[],!1,null,null,null);a.default=e.exports}}]);