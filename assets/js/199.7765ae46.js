(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{683:function(t,s,a){"use strict";a.r(s);var n=a(21),r=Object(n.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"捕获组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕获组","aria-hidden":"true"}},[t._v("#")]),t._v(" 捕获组")]),t._v(" "),a("p",[t._v("在上 一节中，我们看到了量化器一次附加到一个字符，字符类或捕获组。但直到现在，我们还没有详细讨论捕获组的概念。")]),t._v(" "),a("p",[a("strong",[t._v("捕获组")]),t._v(" 是将多个字符视为单个单元的方式。它们是通过将要分组在一组括号内的字符来创建的。\n例如，正则表达式 "),a("code",[t._v("(dog)")]),t._v(' 创建包含字母单个组"d" "o" 和 "g"。与捕获组匹配的输入字符串的部分将保存在存储器中，\n以便以后通过反向引用进行调用（如下文“反向引用”部分所述）。')]),t._v(" "),a("h2",{attrs:{id:"编号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编号","aria-hidden":"true"}},[t._v("#")]),t._v(" 编号")]),t._v(" "),a("p",[t._v("如 Pattern API 中所述，捕获组通过从左到右计算其开始括号进行编号。在表达式中 "),a("code",[t._v("((A)(B(C)))")]),t._v(",有四个这样的组：")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("((A)(B(C)))")])]),t._v(" "),a("li",[a("code",[t._v("(A)")])]),t._v(" "),a("li",[a("code",[t._v("(B(C))")])]),t._v(" "),a("li",[a("code",[t._v("(C)")])])]),t._v(" "),a("p",[t._v("要找出表达式中有多少组，请调用匹配器对象上的 "),a("code",[t._v("groupCount")]),t._v(" 方法,该 groupCount 方法返回 int，\n显示匹配器模式中存在的捕获组的数量。在此示例中，groupCount 将返回该数字 4，显示该模式包含 4 个捕获组。")]),t._v(" "),a("p",[t._v("还有一个特殊的组，组 0，它总是表示整个表达式。该组不包括在总报告中的 groupCount。开始的组(?是纯粹的非捕获组，不捕获文本，不计入组总数。（稍后在 Pattern 类的方法部分中将会看到非捕获组的示例 。）")]),t._v(" "),a("p",[t._v("了解组的编号很重要，因为某些 Matcher 方法接受 int 指定特定的组号作为参数：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("public int start(int group)")]),t._v(": 返回上次匹配操作期间给定组捕获的子序列的起始索引。")]),t._v(" "),a("li",[a("code",[t._v("public int end (int group)")]),t._v(": 返回上次匹配操作期间给定组捕获的最后一个字符的索引，加上一个子序列。")]),t._v(" "),a("li",[a("code",[t._v("public String group (int group):")]),t._v(" 返回在上一个匹配操作期间由给定组捕获的输入子序列。")])]),t._v(" "),a("h2",{attrs:{id:"反向引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反向引用","aria-hidden":"true"}},[t._v("#")]),t._v(" 反向引用")]),t._v(" "),a("p",[t._v("与捕获组匹配的输入字符串的部分保存在存储器中，以便以后通过反向引用进行调用。反向引用在正则表达式中指定为反斜杠"),a("code",[t._v("(\\)")]),t._v("，\n后跟数字，表示要调用的组的编号。例如，表达式 "),a("code",[t._v("(\\d\\d)")]),t._v(" 定义了一行匹配一行中的两位数的捕获组，后者可以通过反向引用在表达式中调用该捕获组 "),a("code",[t._v("\\1")]),t._v("。")]),t._v(" "),a("p",[t._v("要匹配任何2位数，后跟完全相同的两位数，您将使用 "),a("code",[t._v("(\\d\\d)\\1")]),t._v(" 正则表达式：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Test code "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("regexTest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"(\\\\d\\\\d)\\\\1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1212"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Output "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n我发现文本中的 "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1212"')]),t._v(" 在开始索引 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" 和 结束索引 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("如果您更改最后两位数字，则匹配将失败")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Test code "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("regexTest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"(\\\\d\\\\d)\\\\1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1223"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" Output "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\nNo match found"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("        \n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("对于嵌套捕获组，反向引用的工作方式完全相同：指定反斜杠后跟要调用的组的编号。")])])},[],!1,null,null,null);s.default=r.exports}}]);